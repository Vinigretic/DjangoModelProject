# Связи между таблицами
#
# Бывают трех видов:
# один к одному
# один ко многим
# многие ко многим

# Создание связи один ко многим(one to many):
# Создаем необходимые модели и устанавливаем между ними связь
# Для этого используем свойство ForeignKey

# class Company(models.Model):
#     name_company = models.CharField(max_length=50)
#     count_persons = models.SmallIntegerField()
#
#
# class Product(models.Model):
#     company = models.ForeignKey(Company, on_delete=models.CASCADE)
#     name = models.CharField(max_length=100)
#     price = models.FloatField()


# В данном примере модель company связывается с моделью product в строке
# company = models.ForeignKey(Company, on_delete=models.CASCADE)

# ForeignKey - принимает два параметра
# Первый параметр название главной модели
# Второй параметр  on_delete(ОБЯЗАТЕЛЬНЫЙ ПАРАМЕТР) задает опции в зависимости от которых будут изменяться данные в
# связанной таблице  при удалении данных из главной

# on_delete может принимать 5 разных параметров

# 1. models.CASCADE - автоматически удаляет строку из зависимой таблицы, если удаляется строка из главной таблицы
# 2. models.PROTECT - блокирует удаление строки из главной таблицы если с ней связаны какие либо строки в зависимых
#    таблицах
# 3. models.SET_NULL - устанавливает Null в зависимой строке, при удалении строки из главной таблицы,
# Эта связь требует, чтобы поле объекта, на которое указывает ссылка, допускало значение NULL.

# XYZ = models.ForeignKey(WASD, on_delete = models.SET_NULL, null = True)

# 4. models.SET_DEFAULT - устанавливает значение по умолчанию для внешнего ключа в зависимой таблице, в этом случае
# для этого столбца должно быть задано значение по умолчанию, а так же поле объекта, на которое указывает ссылка,
# допускало значение NULL.

# author = models.ForeignKey('Author', on_delete=models.SET_DEFAULT, default=None, null=True)

# 5. models.DO_NOTHING - при удалении строки из главной таблицы в зависомой не происходит никаких изменений

# Операции с моделями

# Обращение к данным главной таблицы через зависимую. Обращаемся к зависимой таблице(Product).Указываем название главной
# таблицы(company) и столбец, данные которого нам нужны
#
# получение названия связанной с товаром компании
# object = Product.objects.get(id=3).company.name_company

# получение id связанной с товаром компании
# Product.objects.get(id=1).company.id

# получение товаров, которые принадлежат к компании "Apple"
# Product.objects.filter(company__name_company="Apple")

# С помощью выражения модель(название)__(два подчеркивания) - можно использовать свойство главной модели для фильтрации
# по объектам зависимой модели.

# С помощью синтаксиса "главная_модель"."зависимая_модель"_set можно изменить направление связи.

# apple = Company.objects.get(name_company="Apple")

# получение всех товаров
# apple.product_set.all()

# получение количества товаров
# apple.product_set.count()

# получение товаров, название которых начинается на "iPhone"
# apple.product_set.filter(name__startwith="iPhone")

# Внесение новых данных если мы хотим что бы они были сразу связанны в главной и в зависимой таблицах, должно происходить
# одновременно

# Первый способ

# Создаем обьект класса - apple
# Создаем новый обьект в БД в главной таблицу

# apple = Company.objects.create(name_company='Apple', count_persons=100)

# Обращаемся к ранее созданному обьекту и зависимой таблице, применяем метод set.create и создаем новый обьект в БД
# в зависимой таблице

# apple.product_set.create(name='Iphone', price=52.3)

# Второй способ - отдельное создание объекта с последующим добавлением

# Обьект в который мы хотим сделать добавление в БД уже должен существовать

# apple = Company.objects.create(name_company='Apple', count_persons=100)

# Создаем обьект класса - ipad зависимая таблица
# ipad = Product(name='Ipad', price=14.5)

# Обращаемся к ранее созданному обьекту для главной таблицы и зависимой таблице, применяем метод set.аdd и создаем
# новый обьект в БД  в зависимой таблице.
# Первым аргументом передаем обьект класса который создали для зависмой таблицы(ipad),
# второй аргумент bulk(по умолчанию True) - выставляем в False

# метод set.аdd (работает по принципу метода update CRUD операции) используем тогда когда нам нужно отредактировать или
# дополнить существующие данные, второй параметр который мы передаем - bulk должен стоять в False,
# иначе создание обьекта  в зависимой таблице не произойдет

# apple.product_set.add(ipad, bulk=False)

# add(): добавляет связь между объектом зависимой модели и объектом главной модели. В своей сути этот метод
# фактически вызывает для модели метод update() для добавления связи. Однако это требует, чтобы обе модели уже
# были в базе данных. И чтобы обойти это ограничение, применяется параметр bulk=False, для того, чтобы объект
# зависимой модели сразу был добавлен и для него была установлена связь.
#
# clear(): удаляет связь между всеми объектами зависимой модели и объектом главной модели. При этом сами объекты
# зависимой модели остаются в базе данных, и для их внешнего ключа устанавливается значение NULL. Поэтому данный
# метод будет работать, если в самой зависимой модели при установки связи использовался
# параметр null=True: ForeignKey(Company, null = True).
#
# remove(): также, как и clear() удаляет связь, только между одним объектом зависимой модели и объектом главной модели.
# При этом также все объекты остаются в бд. И также в самой зависимой модели при установки связи должен использоваться
# параметр null=True

# Связь многие ко многим(many to many)

# Связь многие ко многим описывает ситуацию, когда объект первой модели может одновременно ассоциироваться с
# несколькими объектами второй модели. И наоборот, один объект второй модели может также одновременно быть ассоциирован
# с несколькими объектами первой модели. Например, один студент может посещать несколько курсов, а один курс могут
# посещать несколько студентов.

# Создаем необходимые модели и устанавливаем между ними связь

# Для этого используем класс ManyToManyField()

# Создаются две таблицы, одна из них имеет поле которое будет являться одинаковым для двух таблиц(будет содержать
# одинаковые данные, в случае примера это courses, таблица Students)
# К полю courses применяем класс ManyToManyField и в качестве аргумента передаем название второй таблицы Course
# В результате будет создаваться промежуточная таблица, через которую и будет осуществляться связь.

# class Course(models.Model):
#     courses_name = models.CharField(max_length=200)
#
# class Students(models.Model):
#     student_name = models.CharField(max_length=50)
#     courses = models.ManyToManyField(Course)

# Через атрибут courses в модели Student мы можем получать связанные со студентом курсы и управлять ими.

# создадим студента
# object1 = Students.objects.create(student_name='Lika')

# создадим один курс и добавим его в список курсов object1
# object1.courses.create(courses_name="Algebra")

# получим все курсы студента
# courses = Students.objects.get(student_name='Lika').courses.all()

# получаем всех студентов, которые посещают курс Алгебра
# pupils = Students.objects.filter(courses__courses_name="Algebra")

# Если мы хотим получить информацию о студентах по определенному курсу, нам надо использовать синтаксис _set.

# создадим курс
# ruby = Course.objects.create(courses_name="Ruby")

# создаем студента и добавляем его на курс
# ruby.students_set.create(student_name="Bob")

# отдельно создаем студента и добавляем его на курс
# sam = Students(student_name="Sam")
# sam.save()
# ruby.students_set.add(sam)

# получим всех студентов курса
# students = ruby.students_set.all()

# получим количество студентов по курсу
# number = ruby.students_set.count()

# удялим с курса одного студента
# ruby.students_set.remove(sam)

# Нужно учитывать, что не всегда такая организация связи Многие ко Многим может подойти.
# Например, в данном случае создается промежуточная таблица, которая хранит id студента и id курса.
# Если нам надо в промежуточной таблице харнить еще какие-либо данные, например, дату зачисления студента на курс,
# его оценку и т.д., то такая конфигурация не подойдет. И в этом случае будет более оптимально создать
# промежуточную модель вручную, которая связана отношением один ко многим с обеими моделями.

# One to one

# Отношение один к одному предполагает, что одна строка из одной таблицы может быть связана только с одной строкой
# из другой таблицы. Например, пользователь может иметь какие-либо данные, которые описывают его учетные данные.
# Всю базовую информацию о пользователе, типа имени, возраста, можно выделить в одну модель,
# а учетные данные - логин, пароль, время последнего входа в систему, количество неудачных входов и т.д. -
# в другую модель:

# class User(models.Model):
#     name = models.CharField(max_length=20)
#
#
# class Account(models.Model):
#     login = models.CharField(max_length=20)
#     password = models.CharField(max_length=20)
#     user = models.OneToOneField(User, on_delete=models.CASCADE, primary_key=True)

# Для создания этого отношения один к одному применяется конструктор типа models.OneToOneField().
# Его первый параметр указывает, с какой моделью будет ассоциирована данная сущность (в данном случае ассоциация
# с моделью User).
# Второй параметр on_delete = models.CASCADE говорит, что данные текущей модели (UserAccount) будут удаляться
# в случае удаления связанного объекта главной модели (User).
# Третий параметр primary_key = True указывает,
# что внешний ключ (через который идет связь с главной моделью) в то же время будет выступать и в качестве
# первичного ключа. И соответственно создавать отдельное поле для первичного ключа не надо.

# Операции с моделями
# С помощью свойства user в модели Account мы можем манипулировать связанным объектом модели User:

# создадим пользователя
# sam = User.objects.create(name="Sam")

# создадим аккаунт пользователя Sam
# acc = Account.objects.create(login="1234", password="6565", user=sam)
# user=sam - user это название колонки из модели Account которой присвоили свойство - models.OneToOneField
# # изменяем имя пользователя
# acc.user.name = "Bob"
# # сохраняем изменения в бд
# acc.user.save()

# Однако через модель User мы также можем оказывать влияние на связанный объект Account.
# Несмотря на то, что явным образом в модели User определено только одно свойство - name, при связи один к одному
# неявно создается еще одно свойство, которое называется по имени зависимой модели и которое указывает на связанный
# объект этой модели. То есть в данном случае это свойство будет называться "account":

# создадим пользователя
# tom = User.objects.create(name="Tom")
#
# # создадим аккаунт пользователя
# acc = Accoungit(login="1234", password="6565")
# tom.account = acc
# tom.account.save()
#
# # обновляем данные
# tom.account.login = "qwerty"
# tom.account.password = "123456"
# tom.account.save()